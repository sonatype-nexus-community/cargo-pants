use std::fmt;
use std::io::Write;

#[derive(Debug, Default, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Vulnerability {
    pub title: String,
    pub description: String,
    pub cvss_score: f32,
    pub cvss_vector: String,
    pub reference: String,
}

impl Vulnerability {
    fn get_title_style(&self) -> ansi_term::Style {
        match self.cvss_score as u8 {
            9..=10 => ansi_term::Color::Red.bold(),
            7..=8 => ansi_term::Color::Red.normal(),
            4..=6 => ansi_term::Color::Yellow.normal(),
            _ => ansi_term::Style::default(),
        }
    }

    pub fn output_table(
        &self,
        output: &mut dyn Write,
        enable_color: bool,
        width_override: Option<u16>,
    ) -> std::io::Result<()> {
        use ansi_term::Style;

        let width = match width_override {
            Some(width) => width,
            None => *crate::TERM_WIDTH,
        };

        self.write_divider(output, "─", "╭", "╮", "─", width)?;

        self.write_section(
            output,
            None,
            &self.title,
            self.get_title_style(),
            width,
            enable_color,
        )?;

        self.write_divider(output, "─", "├", "┤", "┬", width)?;

        self.write_section(
            output,
            Some("Description"),
            &self.description,
            Style::default(),
            width,
            enable_color,
        )?;
        self.write_divider(output, "╌", "├", "┤", "┼", width)?;

        self.write_section(
            output,
            Some("CVSS Score"),
            &self.cvss_score.to_string(),
            Style::default(),
            width,
            enable_color,
        )?;
        self.write_divider(output, "╌", "├", "┤", "┼", width)?;

        self.write_section(
            output,
            Some("CVSS Vector"),
            &self.cvss_vector,
            Style::default(),
            width,
            enable_color,
        )?;
        self.write_divider(output, "╌", "├", "┤", "┼", width)?;

        self.write_section(
            output,
            Some("Reference"),
            &self.reference,
            Style::default(),
            width,
            enable_color,
        )?;

        self.write_divider(output, "─", "╰", "╯", "┴", width)?;

        Ok(())
    }

    pub fn write_divider(
        &self,
        output: &mut dyn Write,
        line: &str,
        left: &str,
        right: &str,
        intersection: &str,
        width: u16,
    ) -> std::io::Result<()> {
        write!(output, "{}", left)?;
        write!(output, "{}", line.repeat(13))?;
        write!(output, "{}", intersection)?;
        write!(output, "{}", line.repeat((width - 16.min(width)) as usize))?;
        write!(output, "{}", right)?;

        Ok(())
    }

    pub fn write_section(
        &self,
        output: &mut dyn Write,
        label: Option<&str>,
        text: &str,
        text_style: ansi_term::Style,
        width: u16,
        enable_color: bool,
    ) -> std::io::Result<()> {
        let mut is_first = true;
        let label_wrap_length = 11;
        let wrap_length = match label {
            Some(_) => width - 18.min(width),
            None => width - 4,
        };
        let mut text_wrap_length = width - 18.min(width);
        let lines = textwrap::wrap(text, wrap_length as usize);
        for line in lines {
            write!(output, "│ ")?;
            if let Some(value) = label {
                if is_first {
                    is_first = false;

                    if value.len() < label_wrap_length {
                        for _ in 0..(label_wrap_length - value.len()) {
                            write!(output, " ")?;
                        }
                    }
                    write!(output, "{}", value)?;
                } else {
                    write!(
                        output,
                        "{}",
                        " ".repeat(label_wrap_length.min(width as usize))
                    )?;
                }
                write!(output, " ┆ ")?;
            } else {
                text_wrap_length = width - 4;
            }
            if enable_color {
                write!(output, "{}", text_style.paint(line.clone()))?;
            } else {
                write!(output, "{}", line.clone())?;
            }
            for _ in 0..(text_wrap_length - (line.len() as u16).min(text_wrap_length)) {
                write!(output, " ")?;
            }
            write!(output, " │")?;
        }

        Ok(())
    }
}

impl fmt::Display for Vulnerability {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}\n{}\n{}\n{}\n{}",
            self.title, self.description, self.cvss_score, self.cvss_vector, self.reference
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn convert_output(output: &Vec<u8>) -> &str {
        std::str::from_utf8(output.as_slice()).unwrap()
    }

    #[test]
    fn test_title_style() {
        let mut vulnerability = Vulnerability::default();
        for score in 900..1000 {
            vulnerability.cvss_score = (score / 100) as f32;
            assert_eq!(
                vulnerability.get_title_style(),
                ansi_term::Color::Red.bold()
            );
        }
        for score in 700..800 {
            vulnerability.cvss_score = (score / 100) as f32;
            assert_eq!(
                vulnerability.get_title_style(),
                ansi_term::Color::Red.normal()
            );
        }
        for score in 400..600 {
            vulnerability.cvss_score = (score / 100) as f32;
            assert_eq!(
                vulnerability.get_title_style(),
                ansi_term::Color::Yellow.normal()
            );
        }
    }

    #[test]
    fn test_divider() {
        let mut output = Vec::new();
        let vulnerability = Vulnerability::default();
        vulnerability
            .write_divider(&mut output, "-", "l", "r", "i", 20)
            .expect("Failed to write output");
        let mut line = convert_output(&output);
        assert_eq!(line, "l-------------i----r");

        output.clear();
        vulnerability
            .write_divider(&mut output, "-", "l", "r", "i", 40)
            .expect("Failed to write output");
        line = convert_output(&output);
        assert_eq!(line, "l-------------i------------------------r");
    }

    #[test]
    fn test_section_with_label() {
        use ansi_term::Style;

        let mut output = Vec::new();
        let vulnerability = Vulnerability::default();
        let style = Style::default();
        vulnerability
            .write_section(&mut output, Some("label"), "text", style, 30, false)
            .expect("Failed to write output");
        let line = convert_output(&output);
        assert_eq!(line, "│       label ┆ text         │");
    }

    #[test]
    fn test_section_without_label() {
        use ansi_term::Style;

        let mut output = Vec::new();
        let vulnerability = Vulnerability::default();
        let style = Style::default();
        vulnerability
            .write_section(&mut output, None, "text", style, 30, false)
            .expect("Failed to write output");
        let line = convert_output(&output);
        assert_eq!(line, "│ text                       │");
    }
}
