// Copyright 2019 Glenn Mohre, Sonatype.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use console::style;
use console::StyledObject;
use std::fmt;
use std::io::Write;

#[derive(Debug, Default, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Vulnerability {
    pub title: String,
    pub description: String,
    pub cvss_score: f32,
    pub cvss_vector: String,
    pub reference: String,
}

impl Vulnerability {
    fn print_value_with_color(&self, value: String) -> StyledObject<String> {
        match self.cvss_score as u8 {
            9..=10 => style(value).red().bold(),
            7..=8 => style(value).red(),
            4..=6 => style(value).yellow(),
            _ => style(value).green(),
        }
    }

    pub fn output_table(
        &self,
        output: &mut dyn Write,
        enable_color: bool,
        width_override: Option<u16>,
    ) -> std::io::Result<()> {
        let width = match width_override {
            Some(width) => width,
            None => crate::calculate_term_width(),
        };

        self.write_divider(output, "─", "╭", "╮", "─", width)?;

        self.write_section(output, None, &self.title, width, enable_color)?;

        self.write_divider(output, "─", "├", "┤", "┬", width)?;

        self.write_section(
            output,
            Some("Description"),
            &self.description,
            width,
            enable_color,
        )?;
        self.write_divider(output, "╌", "├", "┤", "┼", width)?;

        self.write_section(
            output,
            Some("CVSS Score"),
            &self.cvss_score.to_string(),
            width,
            enable_color,
        )?;
        self.write_divider(output, "╌", "├", "┤", "┼", width)?;

        self.write_section(
            output,
            Some("CVSS Vector"),
            &self.cvss_vector,
            width,
            enable_color,
        )?;
        self.write_divider(output, "╌", "├", "┤", "┼", width)?;

        self.write_section(
            output,
            Some("Reference"),
            &self.reference,
            width,
            enable_color,
        )?;

        self.write_divider(output, "─", "╰", "╯", "┴", width)?;

        Ok(())
    }

    pub fn write_divider(
        &self,
        output: &mut dyn Write,
        line: &str,
        left: &str,
        right: &str,
        intersection: &str,
        width: u16,
    ) -> std::io::Result<()> {
        write!(output, "{}", left)?;
        write!(output, "{}", line.repeat(13))?;
        write!(output, "{}", intersection)?;
        write!(output, "{}", line.repeat((width - 16.min(width)) as usize))?;
        write!(output, "{}", right)?;

        Ok(())
    }

    pub fn write_section(
        &self,
        output: &mut dyn Write,
        label: Option<&str>,
        text: &str,
        width: u16,
        enable_color: bool,
    ) -> std::io::Result<()> {
        let mut is_first = true;
        let label_wrap_length = 11;

        let wrap_length = match label {
            Some(_) => width - 18.min(width),
            None => width - 4,
        };
        let mut text_wrap_length = width - 18.min(width);
        let lines = textwrap::wrap(text, wrap_length as usize);
        for line in lines {
            write!(output, "│ ")?;
            if let Some(value) = label {
                if is_first {
                    is_first = false;

                    if value.len() < label_wrap_length {
                        for _ in 0..(label_wrap_length - value.len()) {
                            write!(output, " ")?;
                        }
                    }
                    write!(output, "{}", value)?;
                } else {
                    write!(
                        output,
                        "{}",
                        " ".repeat(label_wrap_length.min(width as usize))
                    )?;
                }
                write!(output, " ┆ ")?;
            } else {
                text_wrap_length = width - 4;
            }
            if enable_color {
                write!(
                    output,
                    "{}",
                    self.print_value_with_color(line.to_string().clone())
                )?;
            } else {
                write!(output, "{}", line.clone())?;
            }
            for _ in 0..(text_wrap_length - (line.len() as u16).min(text_wrap_length)) {
                write!(output, " ")?;
            }
            write!(output, " │")?;
        }

        Ok(())
    }
}

impl fmt::Display for Vulnerability {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}\n{}\n{}\n{}\n{}",
            self.title, self.description, self.cvss_score, self.cvss_vector, self.reference
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn convert_output(output: &Vec<u8>) -> &str {
        std::str::from_utf8(output.as_slice()).expect("failed to convert output to UTF-8")
    }

    #[test]
    fn test_divider() {
        let mut output = Vec::new();
        let vulnerability = Vulnerability::default();
        vulnerability
            .write_divider(&mut output, "-", "l", "r", "i", 20)
            .expect("Failed to write output");
        let mut line = convert_output(&output);
        assert_eq!(line, "l-------------i----r");

        output.clear();
        vulnerability
            .write_divider(&mut output, "-", "l", "r", "i", 40)
            .expect("Failed to write output");
        line = convert_output(&output);
        assert_eq!(line, "l-------------i------------------------r");
    }

    #[test]
    fn test_section_with_label() {
        let mut output = Vec::new();
        let vulnerability = Vulnerability::default();
        vulnerability
            .write_section(&mut output, Some("label"), "text", 30, false)
            .expect("Failed to write output");
        let line = convert_output(&output);
        assert_eq!(line, "│       label ┆ text         │");
    }

    #[test]
    fn test_section_without_label() {
        let mut output = Vec::new();
        let vulnerability = Vulnerability::default();
        vulnerability
            .write_section(&mut output, None, "text", 30, false)
            .expect("Failed to write output");
        let line = convert_output(&output);
        assert_eq!(line, "│ text                       │");
    }
}
